<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

<!-- <script src="./common.js"></script> -->

<script>
  /*
    传入一个数值，返回数值里每一个数平方后拼接的结果。
  */
  function squareDigits(num) {
    return String(num).split("").map(item=>{
      return item * item
    }).join("")*1

    // 解法2
    return +String(num).split('').map(function(num){return +num * +num;}).join('');
  }

  // console.log(squareDigits(9119))

  /*
    判断是否能合成一个三角形
  */
  function isTriangle(a,b,c) {
    
    return (a+b>c && a+c>b && b+c>a);

    //解法2:
    [a, b, c] = [a, b, c].sort((x, y) => x-y);
    return a+b > c;

    //解法3：
    Math.max(a,b,c)<(a+b+c)/2

    //解法4：
    var max = Math.max(a, b, c);
    return a + b + c - max > max;

  }

  /* 
    去除字符串中所有空格返回字符串
  */
  function noSpace(x) {
    return x.replace(/\s/g, '');
    return x.split(' ').join('')
  }

  /*
    您可以获得区域的起始编号和结束编号，
    并且应该返回除了数字为5之外的所有数字的和。
    起点和终点都包含在内！
    起始编号始终小于结束编号。这两个数字也可以是负数！
    1,9 -> 1,2,3,4,6,7,8,9 -> Result 8
    4,17 -> 4,6,7,8,9,10,11,12,13,14,16,17 -> Result 12
  */
  function dontGiveMeFive(start, end) {

    var num = 0;
    for(var i=start; i<=end; i++){
      if(i!=5){
        num++
      }
    }
    return num;
  }

  // console.log(dontGiveMeFive(1,9))

  /*
    7kyu
    城市公交车，函数内接收一条公车路线 [] , 路线内每个站上下车的人数都会记录在数组里
    求到终点站时还有多少人在车上 
    例：[10,0] 上车人数为10 人  下车人数为0 
  */
  function busNum (busStops){
    // Good Luck!
    let num = 0
    let count = function(arr){return arr[0] - arr[1]}
    busStops.map(item => {num += count(item)});
    return num

    //解法2：
    // const number = busStops => busStops.reduce((p,n) => p+n[0]-n[1],0)
    // const number = (busStops) => busStops.reduce((rem, [on, off]) => rem + on - off, 0);
    return busStops.map(x => x[0] - x[1]).reduce( (x, y) => x + y);
  }

  // console.log(busNum([[10,0],[3,5],[5,8]]))


  /*
    6kyu 相邻同样的元素只保留一个 
    aaabbcccdc -> abcdc
    
  */
  function abc(str) {
    // let str = "aaabbcccdc";
    // 判断最后一个字符串不等于当前字符串则叠加。
    return str.split("").reduce((pre, current) => { 
      if (pre.substr(pre.length - 1,1) != current ){
        return pre += current
      } else {
        return pre
      }
    });

    // 解法2
    let res = "";
    str.split("").map(item => {
      if( (res.charAt(res.length - 1) || "") != item) {
        res += item
      }
    });
    return res;
  }


  /*
    6kyu  传入数组或字符串相邻同样的元素只保留一个  返回数组
    aaabbcccdc -> [a,b,c,d,c]
    [1,1,1,2,2,1,1] -> [1,2,1]
  */

  function uniqueInOrder (iterable){

    // 解法1：
    var res = [];
    for (var i = 0; i < iterable.length; i++) {
      if (iterable[i] != iterable[i+1]) res.push(iterable[i]);
    }
    return res;

    // 解法2：
    var result = []
    var last
    
    for (var i = 0; i < it.length; i++) {
      if (it[i] !== last) {
        result.push(last = it[i])
      }
    }
    return result
    
    // 解法3：
    return [...iterable].filter((a, i) => a !== iterable[i-1]);

  }

  /*
  https://www.codewars.com/kata/two-to-one/train/javascript
    7kyu  实现一个方法longest 传入两个字符串(s1,s2)   
    返回一个新的 #排序# 字符串，尽可能长，包含不同的字母
    a = "xyaabbbccccdefww"
    b = "xxxxyyyyabklmopq"
    longest(a, b) -> "abcdefklmopqwxy"
  */

  function longest(s1, s2) {
    // s1+s2去重后返回 
    let aa = Array.from(new Set((s1+s2).split(""))).sort().join("");
    console.log(aa);
  }

  // longest("xyaabbbccccdefww","xxxxyyyyabklmopq");


  /*
    编写一方法nameInStr 传入一字符串语句与目标单词， 判断字符串语句内   能否按顺序组成目标单词

    例： 
    nameInStr("Across the rivers", "chris") --> true
                ^      ^  ^^   ^
                c      h  ri   s

    nameInStr("A crew that boards the ship", "chris") --> false
                 cr    h              s i
                 cr                h  s i  
                 c     h      r       s i
  */


  function nameInStr(str, name){
    // 裁剪字符串  获取目标字符串  的每个字符  循环比较语句
    let strArr = str.split("");
    let target = name.split("");
    
    for (let item of strArr) {
      
    }

    // console.log(strArr,target)
  }
  nameInStr("Across the rivers", "chris")

  /*
    编写一个函数判断两个字符串的相似度
    similarity(s1, s2);
    aaaaab, bbbbba   -> xx%
    
  */

  // 编写一个采用数组并将所有零移动到末尾的算法，同时保留其他元素的顺序。
  function moveZeros(arr) {

    // 解法1：
    return arr.filter(function(x) {return x !== 0}).
      concat(arr.filter(function(x) {return x === 0;}));

    // 解法2：
    for(var i = arr.length - 1; i >= 0; i--) {
      if(arr[i] === 0) {
        arr.splice(i, 1);
        arr.push(0);
      }
    }
    return arr;
  }
  // console.log(moveZeros(["a","b",null,"c","d",1,false,1,3,[],1,9,{},0,9,0,0,9,0,0,0]))
  

  // 方法返回数据区间内最大数与最小数
  function minMax(arr){
    return [Math.max.apply(null,arr), Math.min.apply(null, arr)]
  }




</script>
</body>
</html>